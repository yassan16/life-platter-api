# トークン解説ガイド

## 目次

1. [アクセストークンについて](#アクセストークンについて)
2. [JWT・署名検証について](#jwt署名検証について)
3. [リフレッシュトークンについて](#リフレッシュトークンについて)
4. [アクセストークンとリフレッシュトークンの違い](#アクセストークンとリフレッシュトークンの違い)
5. [2つに分ける理由](#2つに分ける理由)
6. [セキュリティ観点でのメリット](#セキュリティ観点でのメリット)
7. [処理フロー図](#処理フロー図)

---

## アクセストークンについて

アクセストークンは「入館証」のようなもの。

- **用途**: APIにアクセスするための認証情報
- **使用タイミング**: リクエストごとに送信する
- **有効期限**: 短命（30分）
- **保存場所**: クライアントのみ（サーバーには保存しない）

```
Client → API呼び出し時
         Authorization: Bearer <access_token>
```

### なぜサーバーに保存しないのか

1. **JWTは自己完結型**: 署名検証だけで認証できる（DB問い合わせ不要）
2. **パフォーマンス**: 毎リクエストでDBアクセスが不要（高速）
3. **短命**: 30分で期限切れになるため、わざわざ管理する必要がない

---

## JWT・署名検証について

### JWTの構造

```
eyJhbGciOiJIUzI1NiIs...

├── Header    : アルゴリズム情報（HS256など）
├── Payload   : ユーザーID、有効期限などのデータ
└── Signature : 改ざん検知用の署名
```

### 署名検証の仕組み

```
┌─────────────────────────────────────────────────────────────┐
│ サーバー側の検証処理                                          │
├─────────────────────────────────────────────────────────────┤
│ 1. トークンを受け取る                                         │
│ 2. Header + Payload を秘密鍵で署名                           │
│ 3. 生成した署名とトークン内の Signature を比較                 │
│ 4. 一致すれば認証OK、不一致なら改ざん検知                      │
└─────────────────────────────────────────────────────────────┘
```

- **メリット**: DBに問い合わせずにメモリ内で完結
- **デメリット**: 一度発行すると無効化できない（期限切れを待つしかない）

---

## リフレッシュトークンについて

リフレッシュトークンは「入館証を再発行するための身分証明書」のようなもの。

- **用途**: 新しいアクセストークンを取得するための認証情報
- **使用タイミング**: アクセストークンが切れた時だけ使う
- **有効期限**: 長命（7日）
- **保存場所**: クライアント + サーバーDB（ハッシュ化して保存）

### なぜサーバーに保存するのか

1. **長命なので無効化が必要**: 7日間有効なため、漏洩時に即座に無効化できる仕組みが必要
2. **ログアウト機能**: ログアウト時に `revoked_at` を設定して即座に無効化
3. **セキュリティ**: 不正利用検知時に該当トークンだけ無効化できる

### DB保存形式

```
refresh_tokens テーブル
┌──────────────┬───────────────┬─────────────────────────────┐
│ カラム        │ 型            │ 説明                         │
├──────────────┼───────────────┼─────────────────────────────┤
│ id           │ CHAR(36)      │ UUID（主キー）               │
│ user_id      │ CHAR(36)      │ FK → users.id               │
│ token_hash   │ VARCHAR(255)  │ トークン値（ハッシュ化済み）   │
│ expires_at   │ DATETIME      │ 有効期限                     │
│ revoked_at   │ DATETIME      │ 無効化日時（nullable）        │
│ created_at   │ DATETIME      │ 作成日時                     │
└──────────────┴───────────────┴─────────────────────────────┘
```

---

## アクセストークンとリフレッシュトークンの違い

| 項目 | アクセストークン | リフレッシュトークン |
|------|-----------------|-------------------|
| **用途** | API認証 | トークン再発行 |
| **有効期限** | 短い（30分） | 長い（7日） |
| **使用頻度** | 毎リクエスト | 30分に1回程度 |
| **サーバー保存** | しない | する（ハッシュ化） |
| **無効化** | できない（期限切れを待つ） | できる（即座に） |
| **漏洩リスク** | 低（短命のため） | 高（長命のため要管理） |

---

## 2つに分ける理由

### セキュリティとUXのバランス

```
┌─────────────────────────────────────────────────────────────┐
│ もしアクセストークンだけだったら...                            │
├─────────────────────────────────────────────────────────────┤
│ 【短命（30分）の場合】                                        │
│   → 30分ごとに再ログインが必要（UXが悪い）                     │
│                                                             │
│ 【長命（7日）の場合】                                         │
│   → 漏洩時に7日間悪用される（セキュリティが悪い）               │
│   → 毎リクエストでDB照会が必要（パフォーマンスが悪い）          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 2つに分けることで...                                          │
├─────────────────────────────────────────────────────────────┤
│ • アクセストークン: 短命でセキュア、DB不要で高速               │
│ • リフレッシュトークン: 長命でUX向上、必要時のみDB照会          │
│                                                             │
│ → セキュリティとUXの両立が可能                                 │
└─────────────────────────────────────────────────────────────┘
```

### なぜ両方のトークンを返すのか

ログイン時にアクセストークンだけでなく、リフレッシュトークンも一緒に返す理由：

```
【アクセストークンのみの場合】

ログイン → access_token(30分) 取得
    ↓
30分後...
    ↓
access_token 期限切れ
    ↓
再度ログイン（email + password 入力）← ユーザーにとって面倒
    ↓
1日に何度もログインが必要 → UXが悪い
```

```
【両方返す場合】

ログイン → access_token(30分) + refresh_token(7日) 取得
    ↓
30分後...
    ↓
access_token 期限切れ
    ↓
refresh_token を使って自動で新しい access_token を取得
    ↓
ユーザーは気づかない → UXが良い
```

**ポイント**: ログイン時（ユーザーがemail+passwordを入力した時）が唯一の認証タイミングなので、その時点で両方発行しておく必要がある。

### 再ログインが不要になる条件

| 状況 | 結果 |
|------|------|
| 7日以内に通信した | 再ログイン不要（自動更新） |
| 7日以上放置した | 再ログインが必要 |

```
【7日以内に使った場合】

Day 1: ログイン → access_token + refresh_token 取得
Day 3: アプリ起動 → access_token期限切れ → refresh_tokenで自動更新
       → 新しい access_token + refresh_token 取得（期限リセット）
Day 8: アプリ起動 → また自動更新
       → 使い続ける限り再ログイン不要
```

```
【7日以上放置した場合】

Day 1: ログイン → access_token + refresh_token 取得
Day 10: アプリ起動
        → access_token期限切れ（30分で切れている）
        → refresh_tokenも期限切れ（7日で切れている）
        → 再ログインが必要
```

### リフレッシュトークンローテーション

リフレッシュ時には**両方のトークンが新規発行**される：

```
Client → refresh_token を送信 → Server
Server → access_token(新規) + refresh_token(新規) → Client
         ↑                      ↑
         新しい                 これも新しい
```

**理由**: セキュリティ対策。古いリフレッシュトークンは無効化されるため、漏洩しても被害を限定できる。

---

## セキュリティ観点でのメリット

### 1. アクセストークン漏洩時の被害が限定的

```
【アクセストークンが盗まれた場合】

攻撃者: アクセストークンを入手
        ↓
        30分間だけ悪用可能
        ↓
        30分後に自動で無効化
        ↓
        被害は最小限
```

| トークン | 有効期限 | 漏洩時のリスク |
|---------|---------|---------------|
| アクセストークン | 30分 | 30分間だけ悪用される |
| 長命トークン1つだけ | 7日 | 7日間悪用される |

### 2. リフレッシュトークンローテーションで不正検知

```
【リフレッシュトークンが盗まれた場合】

正規ユーザー: refresh_token_A を使用
              → 新しい refresh_token_B を取得
              → refresh_token_A は無効化

攻撃者: 盗んだ refresh_token_A を使用
        → 「既に使用済み」エラー
        → 不正アクセス検知
        → 全トークン無効化（強制ログアウト）
```

### 3. 即座に無効化が可能

```
【パスワード変更・不正アクセス検知時】

管理者/ユーザー: 「このセッションを無効化したい」
                 ↓
サーバー: refresh_tokens テーブルの revoked_at を更新
          ↓
          即座にそのセッションは無効化
          ↓
          次回のリフレッシュ時に強制ログアウト
```

アクセストークンだけでは**即座の無効化ができない**（期限切れを待つしかない）。

### 4. 攻撃対象の分離

```
【アクセストークン】
・毎リクエストで送信 → 盗まれやすい
・でも30分で無効 → 被害限定的

【リフレッシュトークン】
・30分に1回だけ送信 → 盗まれにくい
・長命だが使用頻度が低い → 露出機会が少ない
```

| トークン | 送信頻度 | 漏洩リスク | 有効期限 |
|---------|---------|-----------|---------|
| アクセス | 高（毎回） | 高 | 短（30分） |
| リフレッシュ | 低（30分に1回） | 低 | 長（7日） |

**リスク × 影響 を最小化する設計。**

### 5. 放置セッションの自動無効化

```
【ユーザーがログアウトを忘れた場合】

共有PCでログイン → ログアウト忘れ
        ↓
7日後に自動でセッション無効化
        ↓
第三者が使おうとしても再ログインが必要
```

### セキュリティメリットまとめ

| メリット | 説明 |
|---------|------|
| **被害の限定** | アクセストークン漏洩は30分で影響終了 |
| **不正検知** | トークンローテーションで二重使用を検知 |
| **即座の無効化** | DB管理で任意のタイミングで無効化可能 |
| **攻撃対象の分離** | 高頻度送信（短命）と低頻度送信（長命）を分離 |
| **自動クリーンアップ** | 放置セッションは7日で自動無効化 |

---

## 処理フロー図

### 全体フロー

```
┌─────────────────────────────────────────────────────────────┐
│ 1. ログイン時                                                │
├─────────────────────────────────────────────────────────────┤
│  Client → POST /api/users/login → Server                    │
│  Server → access_token(30分) + refresh_token(7日) → Client   │
│  Client: 両トークンをローカルに保存                            │
│  Server: refresh_token をDBにハッシュ化して保存               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. API呼び出し（通常時）                                      │
├─────────────────────────────────────────────────────────────┤
│  Client → GET /api/users/me (Authorization: Bearer access_token) │
│  Server → 署名検証（DB不要）→ 200 OK + ユーザー情報            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. アクセストークン期限切れ時                                  │
├─────────────────────────────────────────────────────────────┤
│  Client → GET /api/users/me (Authorization: Bearer access_token) │
│  Server → 401 Unauthorized (INVALID_TOKEN)                   │
│                                                             │
│  【リフレッシュ処理が発動】                                    │
│  Client → POST /api/users/refresh { refresh_token: "..." }   │
│  Server → DB照会 → 新しい access_token + refresh_token       │
│  Client: トークンを更新して元のAPIを再リクエスト                │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. ログアウト時                                              │
├─────────────────────────────────────────────────────────────┤
│  Client → POST /api/users/logout (Authorization: Bearer token) │
│  Server → refresh_token の revoked_at を更新（無効化）        │
│  Client → ローカルのトークンを削除                             │
└─────────────────────────────────────────────────────────────┘
```

### 有効期限の判断

| 判断方法 | 説明 | 推奨 |
|---------|------|:----:|
| サーバー側で判断 | 401エラー受信時にリフレッシュ発動 | ◎ |
| クライアント側で事前判断 | JWTをデコードして期限チェック | ○ |

基本は**サーバー側で判断**（401エラー受信時）が推奨。クライアント側での事前判断はパフォーマンス最適化として検討。
