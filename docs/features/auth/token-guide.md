# トークン解説ガイド

## 目次

1. [アクセストークンについて](#アクセストークンについて)
2. [JWT・署名検証について](#jwt署名検証について)
3. [リフレッシュトークンについて](#リフレッシュトークンについて)
4. [アクセストークンとリフレッシュトークンの違い](#アクセストークンとリフレッシュトークンの違い)
5. [2つに分ける理由](#2つに分ける理由)
6. [処理フロー図](#処理フロー図)

---

## アクセストークンについて

アクセストークンは「入館証」のようなもの。

- **用途**: APIにアクセスするための認証情報
- **使用タイミング**: リクエストごとに送信する
- **有効期限**: 短命（30分）
- **保存場所**: クライアントのみ（サーバーには保存しない）

```
Client → API呼び出し時
         Authorization: Bearer <access_token>
```

### なぜサーバーに保存しないのか

1. **JWTは自己完結型**: 署名検証だけで認証できる（DB問い合わせ不要）
2. **パフォーマンス**: 毎リクエストでDBアクセスが不要（高速）
3. **短命**: 30分で期限切れになるため、わざわざ管理する必要がない

---

## JWT・署名検証について

### JWTの構造

```
eyJhbGciOiJIUzI1NiIs...

├── Header    : アルゴリズム情報（HS256など）
├── Payload   : ユーザーID、有効期限などのデータ
└── Signature : 改ざん検知用の署名
```

### 署名検証の仕組み

```
┌─────────────────────────────────────────────────────────────┐
│ サーバー側の検証処理                                          │
├─────────────────────────────────────────────────────────────┤
│ 1. トークンを受け取る                                         │
│ 2. Header + Payload を秘密鍵で署名                           │
│ 3. 生成した署名とトークン内の Signature を比較                 │
│ 4. 一致すれば認証OK、不一致なら改ざん検知                      │
└─────────────────────────────────────────────────────────────┘
```

- **メリット**: DBに問い合わせずにメモリ内で完結
- **デメリット**: 一度発行すると無効化できない（期限切れを待つしかない）

---

## リフレッシュトークンについて

リフレッシュトークンは「入館証を再発行するための身分証明書」のようなもの。

- **用途**: 新しいアクセストークンを取得するための認証情報
- **使用タイミング**: アクセストークンが切れた時だけ使う
- **有効期限**: 長命（7日）
- **保存場所**: クライアント + サーバーDB（ハッシュ化して保存）

### なぜサーバーに保存するのか

1. **長命なので無効化が必要**: 7日間有効なため、漏洩時に即座に無効化できる仕組みが必要
2. **ログアウト機能**: ログアウト時に `revoked_at` を設定して即座に無効化
3. **セキュリティ**: 不正利用検知時に該当トークンだけ無効化できる

### DB保存形式

```
refresh_tokens テーブル
┌──────────────┬───────────────┬─────────────────────────────┐
│ カラム        │ 型            │ 説明                         │
├──────────────┼───────────────┼─────────────────────────────┤
│ id           │ CHAR(36)      │ UUID（主キー）               │
│ user_id      │ CHAR(36)      │ FK → users.id               │
│ token_hash   │ VARCHAR(255)  │ トークン値（ハッシュ化済み）   │
│ expires_at   │ DATETIME      │ 有効期限                     │
│ revoked_at   │ DATETIME      │ 無効化日時（nullable）        │
│ created_at   │ DATETIME      │ 作成日時                     │
└──────────────┴───────────────┴─────────────────────────────┘
```

---

## アクセストークンとリフレッシュトークンの違い

| 項目 | アクセストークン | リフレッシュトークン |
|------|-----------------|-------------------|
| **用途** | API認証 | トークン再発行 |
| **有効期限** | 短い（30分） | 長い（7日） |
| **使用頻度** | 毎リクエスト | 30分に1回程度 |
| **サーバー保存** | しない | する（ハッシュ化） |
| **無効化** | できない（期限切れを待つ） | できる（即座に） |
| **漏洩リスク** | 低（短命のため） | 高（長命のため要管理） |

---

## 2つに分ける理由

### セキュリティとUXのバランス

```
┌─────────────────────────────────────────────────────────────┐
│ もしアクセストークンだけだったら...                            │
├─────────────────────────────────────────────────────────────┤
│ 【短命（30分）の場合】                                        │
│   → 30分ごとに再ログインが必要（UXが悪い）                     │
│                                                             │
│ 【長命（7日）の場合】                                         │
│   → 漏洩時に7日間悪用される（セキュリティが悪い）               │
│   → 毎リクエストでDB照会が必要（パフォーマンスが悪い）          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 2つに分けることで...                                          │
├─────────────────────────────────────────────────────────────┤
│ • アクセストークン: 短命でセキュア、DB不要で高速               │
│ • リフレッシュトークン: 長命でUX向上、必要時のみDB照会          │
│                                                             │
│ → セキュリティとUXの両立が可能                                 │
└─────────────────────────────────────────────────────────────┘
```

---

## 処理フロー図

### 全体フロー

```
┌─────────────────────────────────────────────────────────────┐
│ 1. ログイン時                                                │
├─────────────────────────────────────────────────────────────┤
│  Client → POST /auth/login → Server                         │
│  Server → access_token(30分) + refresh_token(7日) → Client   │
│  Client: 両トークンをローカルに保存                            │
│  Server: refresh_token をDBにハッシュ化して保存               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. API呼び出し（通常時）                                      │
├─────────────────────────────────────────────────────────────┤
│  Client → GET /users/me (Authorization: Bearer access_token) │
│  Server → 署名検証（DB不要）→ 200 OK + ユーザー情報            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. アクセストークン期限切れ時                                  │
├─────────────────────────────────────────────────────────────┤
│  Client → GET /users/me (Authorization: Bearer access_token) │
│  Server → 401 Unauthorized (INVALID_TOKEN)                   │
│                                                             │
│  【リフレッシュ処理が発動】                                    │
│  Client → POST /auth/refresh { refresh_token: "..." }        │
│  Server → DB照会 → 新しい access_token + refresh_token       │
│  Client: トークンを更新して元のAPIを再リクエスト                │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. ログアウト時                                              │
├─────────────────────────────────────────────────────────────┤
│  Client → POST /auth/logout (Authorization: Bearer token)    │
│  Server → refresh_token の revoked_at を更新（無効化）        │
│  Client → ローカルのトークンを削除                             │
└─────────────────────────────────────────────────────────────┘
```

### 有効期限の判断

| 判断方法 | 説明 | 推奨 |
|---------|------|:----:|
| サーバー側で判断 | 401エラー受信時にリフレッシュ発動 | ◎ |
| クライアント側で事前判断 | JWTをデコードして期限チェック | ○ |

基本は**サーバー側で判断**（401エラー受信時）が推奨。クライアント側での事前判断はパフォーマンス最適化として検討。
